/* -=- Move Scripts -=-
 * Specialized scripts made for specific moves within the game.
 *

*/

#library "A_Moves"
#include "zcommon.acs"
#include "8bdmlib.acs"
#import "tools.acs"
#import "DB_Player.acs"
#import "DB_Data.acs"
#import "Dex_Pokemon.acs"
#import "Dex_Types.acs"
#import "Dex_Moves.acs"
#import "WEPACS.acs"
#import "A_Stats.acs"
#import "A_Leveling.acs"
#import "Dex_Leveling.acs"
#import "Dex_BaseStats.acs"
#import "G_Action.acs"
Script "SketchGrab" (Void)
{

// -=- meant to work with the targeter, grabs the move that your tracer currently has and replaces sketch with it -=-


// -=- first, grab what slot this sketch is on -=-
int ThisWeapon = WhichWeapon();
int MyTID = ActivatorTID();
Int TracerTID = ACS_NamedExecuteWithResult("Tracer_GetTID",0);
Int SketchSlot;

for(int i=1;i<=4;i++)
    {
    if(CheckInventory(StrParam(s:weapons_ammo[ThisWeapon][0],i:i))){SketchSlot = i; break;}
    }

SetActivator(TracerTID,AAPTR_DEFAULT);
int SketchWeapon = WhichWeapon();
SetActivator(MyTID,AAPTR_DEFAULT);

// -=- check if you have this weapon already -=-

for(i=1;i<=4;i++)
    {
    if(CheckInventory(StrParam(s:weapons_ammo[SketchWeapon][0],i:i)))
        {
        print(s:"You already know ",s:weapons_ammo[SketchWeapon][2],s:"!!"); 
        Terminate;
        }
    }

GiveInventory(StrParam(s:weapons_ammo[SketchWeapon][0],i:SketchSlot),1);
TakeInventory(StrParam(s:weapons_ammo[ThisWeapon][0],i:SketchSlot),99);

//now if the player has less than 4 weapons, let's relearn sketch on the
//next empty slot
if(SketchSlot<4)
    {
        GiveInventory(StrParam(s:weapons_ammo[SKETCH][0],i:SketchSlot+1),1);

        /* Now this is assuming that since most pokemon always have 4 moves, and there is no
         * way to delete moves at all, since smeargle starts with only sketch, the next slot
         * will always be empty since smeargle is also barred from learning TMs
        */
    }
    SetWeapon(StrParam(s:weapons_ammo[SketchWeapon][0],i:SketchSlot));
}

Script "ProtectBarrierWarper" (void) CLIENTSIDE
{
	int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	
	// Loop if shield is active
	while(GetActorProperty(Player, APROP_HEALTH)>0
	&& CheckActorInventory(Player, "ProtectGuard") > 0
	){
		Delay(1);
	}
	
    // Remove
    SetActorState(0,"Death");
    Delay(17);
	Thing_Remove(0);
}

Script "AlertFXWarper" (void) CLIENTSIDE
{
	int Player = ACS_NamedExecuteWithResult("core_gettarget",0);
	
	// Loop if shield is active
	while(GetActorProperty(Player, APROP_HEALTH)>0
	&& CheckActorInventory(Player, "CringeGuard") > 0
	){
		Delay(1);
	}
	
    // Remove
    SetActorState(0,"Death");
    Delay(17);
	Thing_Remove(0);
}

Script "FalseSwipeDamage" (int Damage)
{
int TargTID = ACS_NamedExecuteWithResult("core_gettarget",0);
int TracTID = ACS_NamedExecuteWithResult("core_gettracer",0);
ACS_NamedExecuteAlways("FalseBuddha",0,TracTID,1);
Delay(1);
Thing_Damage2(TracTID,Damage,"FalseSwipe");
ACS_NamedExecuteAlways("FalseBuddha",0,TracTID,0);
}

Script "FalseBuddha" (int TID, int State)
{
SetActivator(TID,AAPTR_DEFAULT);
SetPlayerProperty(0, State, PROP_BUDDHA);
}

Script "FalseEXPAward" (void)
{
if(EXPTime() == 0){Terminate;}
int TargTID = ACS_NamedExecuteWithResult("core_gettarget",0);
int VictimPN = Playernumber();
    int PlayerLVL = GetCvar(StrParam(s:"PlayerLevel_",i:VictimPN));
    int PlayerDexNum = GetCvar(StrParam(s:"PlayerDEXNum_",i:VictimPN));
    int VictimFrags = ACS_NamedExecuteWithResult("GetPlayerFrags",VictimPN);
    int VictimBounty = StatDEX[PlayerDexNum][6];
int EXPAward = VictimBounty*PlayerLVL;

//SetActivatorToTarget(0);
//int KillerTID = ActivatorTID();
// --=- no exp if you kill yourself
//if(VictimTID == KillerTID){Terminate;}

ACS_NamedExecuteAlways("GivePlayerEXP",0,TargTID-1000,EXPAward);
//log(s:GetTeamProperty(PlayerTeam(),TPROP_Name), s:" Team EXP Award ", i:TeamEXPAward[PlayerTeam()]);
}

Script "GrabMoveCount" (int WepID)
{
// grabs generic count inventories for Various moves
int FiringPlayer;
str CountActor = StrParam(s:weapons_ammo[WepID][2],s:"Count");
int Output;

if(ActivatorTID() <= 999)
	{FiringPlayer= ACS_ExecuteWithResult(257, 0); }//Returns the target of the activator
else if(ActivatorTID() >= EntityTID && ActivatorTID() <= (EntityTID+6499))
	{FiringPlayer= ACS_ExecuteWithResult(257, 0);} //Actor is a player spawed entity, Returns the target of the activator
else{FiringPlayer=ActivatorTID();}

if(FiringPlayer == 0){Output = CheckInventory(CountActor);}
else {Output = CheckActorInventory(FiringPlayer,CountActor);}

SetResultValue(Output);
}

#DEFINE HAZTID 37000 // 37| TeamNum | Hazard num
#DEFINE HAZMAX 50
int HazTIDRecord[4];

Script "HazardTID" (Void)
{

if(activatorTID() != 0){Terminate;}

int FiringPlayer = ACS_NamedExecuteWithResult("core_gettarget",0);
Int TeamNum = ACS_NamedExecuteWithResult("core_getplayerteam",FiringPlayer-1000);

int newHazTID = HazTIDRecord[TeamNum];
int MaxHazTID = HAZTID+(TeamNum*100)+HAZMAX;

if(!newHazTID){newHazTID = HAZTID+(TeamNum*100);}
else if(newHazTID > MaxHazTID){newHazTID = newHazTID-HAZMAX;}
until(!IsTIDUsed(newHazTID)){Thing_remove(newHazTID);}
Thing_ChangeTID(0,newHazTID);
HazTIDRecord[TeamNum] = newHazTID+1;

}

Script "HazardScrub" (int ScrubRange)
{
    int FiringPlayer = ACS_NamedExecuteWithResult("core_gettarget",0);
    Int TeamNum = ACS_NamedExecuteWithResult("core_getplayerteam",FiringPlayer-1000);
int MaxTeams = GetCvar("sv_maxteams");
int CheckTID;

For(int i; i<HAZMAX;i++)
    {
    for(int j; j < MaxTeams; j++)
    {
    CheckTID = HAZTID + (j*100)+ i;
        if(IsTIDUsed(CheckTID) 
            && xyzDistance(0,CheckTID) <= ScrubRange
            && j != TeamNum){SetActorState(CheckTID,"Purge");}
    }
    j = 0;
    }

}


// Make's Smoke less Opaque for teams
script "TeamSmoke"  (VOID) CLIENTSIDE
{

    int cln = consolePlayerNumber();
	int FiringPlayer= ACS_ExecuteWithResult(257, 0) - 1000;
    if( GetPlayerInfo(cln, PLAYERINFO_TEAM) == GetPlayerInfo(FiringPlayer, PLAYERINFO_TEAM))//(PlayerClass((consolePlayerNumber() >= SUPPORTSTART) && PlayerClass((consolePlayerNumber()) <= SUPPORTEND)))
    {
       SetActorProperty(0,APROP_ALPHA,0.05);
    }
}

Script "AbsorbEffect" (int Per)
{
    Delay(1);
    While(GetUserVariable(0,"user_HitMemory") < 1){Delay(1); }
int Amount = GetUserVariable(0,"user_HitMemory");
int DrainerTID = ACS_NamedExecuteWithResult("core_gettarget",0);

if(!CheckActorInventory(DrainerTID,"Absorb_Active")){Terminate;}

Amount = (Amount*Per)/100;
if(Amount<1) Amount = 1;

GiveInventory("AbsorbDrainFXSpawner",1);
SetActivator(DrainerTID,AAPTR_DEFAULT);
ACS_NamedExecuteAlways("PKMNACS_Basic(Over)Heal",0,0,Amount);
}

Script "LifeDrainEffect" (int Per)
{
    Delay(1);
    While(GetUserVariable(0,"user_HitMemory") < 1){Delay(1); }
int Amount = GetUserVariable(0,"user_HitMemory");
int DrainerTID = ACS_NamedExecuteWithResult("core_gettarget",0);

Amount = (Amount*Per)/100;
if(Amount<1) Amount = 1;

SetActivator(DrainerTID,AAPTR_DEFAULT);
ACS_NamedExecuteAlways("PKMNACS_Basic(Over)Heal",0,0,Amount);
}

Script "RemoteControlActor" (int ActorSpeed)
{

    int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget",0);


    int InputButtons;
    int InputOldButtons; 
    int UpInput;
    int DownInput;
    int LeftInput;
    int RightInput;
    Int ConfirmInput;
    Int CancelInput;


    int Velx;
    int Vely;
    int Velx2;
    int Vely2;
    int Angle;
    while(GetActorProperty(0, APROP_HEALTH)>0)
    {	
        // - Grab Inputs -
        InputButtons = GetPlayerInput(OwnerTID-1000, INPUT_BUTTONS);
        UpInput = ButtonCheck(InputButtons, InputOldButtons, BT_FORWARD);
        DownInput = ButtonCheck(InputButtons, InputOldButtons, BT_BACK);
        LeftInput = ButtonCheck(InputButtons, InputOldButtons, BT_MOVELEFT);
        RightInput = ButtonCheck(InputButtons, InputOldButtons, BT_MOVERIGHT);
        ConfirmInput = ButtonCheck(InputButtons, InputOldButtons, BT_ATTACK);
        CancelInput = ButtonCheck(InputButtons, InputOldButtons, BT_AltATTACK);
        Angle = GetActorAngle(OwnerTID);
        Velx = 0;
        vely = 0;
        VelX2 = 0;
        Vely2 = 0;
        if(UpInput != DownInput)
            {
                if(UpInput == 3){Velx = FixedMul(cos(angle),  ActorSpeed*65536); vely = FixedMul(Sin(angle),  ActorSpeed*65536);}
                if(DownInput == 3){Velx = FixedMul(cos(angle), -ActorSpeed*65536); vely = FixedMul(Sin(angle),  -ActorSpeed*65536);}
            }  

        if(LeftInput != RightInput)
            {
                if(LeftInput == 3){Velx2 = FixedMul(cos(-angle),  ActorSpeed*65536); vely2 = FixedMul(Sin(-angle),  ActorSpeed*65536);}
                if(RightInput == 3){Velx2 = FixedMul(cos(-angle), -ActorSpeed*65536); vely2 = FixedMul(Sin(-angle),  -ActorSpeed*65536);}
            }    
log(f:Velx);
            if(CancelInput == 1){Thing_Remove(0); Terminate;}
            if(ConfirmInput == 1){SetActorState(0,"Trigger");}
    SetActorVelocity(0, velx+vely2, vely+velx2, 0, FALSE, FALSE);
    SetActorAngle (0,Angle );
    Delay(1);
	InputOldButtons = InputButtons;
    }


}


Script "GrabRemoteCoor" (int T)
{
int output;
switch(T)
    {
    case 0: output = GetUserVariable(0,"user_RemoteX"); break;
    case 1: output = GetUserVariable(0,"user_RemoteY"); break;
    case 2: output = GetUserVariable(0,"user_RemoteZ"); break;
    }
SetResultValue(output);
}

script "SnapToRemote" (int X_Placement)
{
    int OwnerTID = ACS_NamedExecuteWithResult("core_gettarget",0);
    int OwnerPnum = OwnerTID-1000;
    Warp(9100+OwnerPnum, X_Placement, 0, 0, 0, WARPF_ABSOLUTEPOSITION|WARPF_USECALLERANGLE|WARPF_INTERPOLATE);

}